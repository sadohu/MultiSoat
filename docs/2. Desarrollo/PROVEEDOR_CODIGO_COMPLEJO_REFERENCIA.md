# C√ìDIGO COMPLEJO PROVEEDOR - REFERENCIA FUTURA

## üìù **PROP√ìSITO**
Este archivo contiene el c√≥digo complejo que ten√≠a la funci√≥n proveedor antes de simplificarla para productividad. Incluye sistema de auditor√≠a, autenticaci√≥n avanzada, validaciones complejas y filtros avanzados.

---

## üîß **IMPORTS COMPLEJOS**

```typescript
import { Validator } from "shared/utils/Validator.ts";
import {
  enrichWithAuditInfo,
  withAudit,
  withOptionalAuth,
} from "shared/utils/audit.ts";
import { getSupabaseClient } from "shared/utils/client-auth.ts";
```

---

## üìä **CONSTANTES Y VALIDACIONES AVANZADAS**

```typescript
// Constantes avanzadas
const VALID_ESTADOS = ["registrado", "inactivo"] as const;
const VALID_TIPO_DOCUMENTOS = ["RUC", "DNI", "CE"] as const;

// Funciones de validaci√≥n compleja
function validatePaginationParams(
  page: string,
  limit: string,
): { valid: boolean; error?: string; page?: number; limit?: number } {
  const parsedPage = parseInt(page || "1");
  const parsedLimit = parseInt(limit || DEFAULT_PAGE_LIMIT.toString());

  if (isNaN(parsedPage) || parsedPage < 1) {
    return {
      valid: false,
      error: "El par√°metro 'page' debe ser un n√∫mero entero mayor a 0",
    };
  }
  if (isNaN(parsedLimit) || parsedLimit < 1 || parsedLimit > MAX_PAGE_LIMIT) {
    return {
      valid: false,
      error: `El par√°metro 'limit' debe ser un n√∫mero entero entre 1 y ${MAX_PAGE_LIMIT}`,
    };
  }

  return { valid: true, page: parsedPage, limit: parsedLimit };
}

function validateFilterParams(
  estado: string,
  tipo_documento: string,
): { valid: boolean; error?: string } {
  if (estado && !VALID_ESTADOS.includes(estado as typeof VALID_ESTADOS[number])) {
    return {
      valid: false,
      error: `El par√°metro 'estado' debe ser uno de: ${VALID_ESTADOS.join(", ")}`,
    };
  }
  if (
    tipo_documento &&
    !VALID_TIPO_DOCUMENTOS.includes(
      tipo_documento as typeof VALID_TIPO_DOCUMENTOS[number],
    )
  ) {
    return {
      valid: false,
      error: `El par√°metro 'tipo_documento' debe ser uno de: ${VALID_TIPO_DOCUMENTOS.join(", ")}`,
    };
  }
  return { valid: true };
}
```

---

## üîç **SISTEMA DE FILTROS Y B√öSQUEDA AVANZADA**

```typescript
function sanitizeSearchTerm(search: string): string {
  return search.replace(/[%_'"\\]/g, "");
}

// deno-lint-ignore no-explicit-any
function applyFilters(
  query: any,
  search: string,
  estado: string,
  tipo_documento: string,
) {
  if (search) {
    const sanitizedSearch = sanitizeSearchTerm(search);
    if (sanitizedSearch.length > 0) {
      query = query.or(
        `nombre.ilike.%${sanitizedSearch}%,razon_social.ilike.%${sanitizedSearch}%,numero_documento.ilike.%${sanitizedSearch}%`,
      );
    }
  }
  if (estado) {
    query = query.eq("estado", estado);
  }
  if (tipo_documento) {
    query = query.eq("tipo_documento", tipo_documento);
  }
  return query;
}
```

---

## üõ°Ô∏è **MANEJO AVANZADO DE ERRORES**

```typescript
// deno-lint-ignore no-explicit-any
function handleDatabaseError(error: any): Response {
  let errorMessage = "Error desconocido en consulta";
  let errorCode = "unknown";

  try {
    if (error.code) {
      errorCode = error.code;
    }

    if (error.message && error.message.startsWith('{"')) {
      errorMessage = "Error de consulta en base de datos";
    } else if (error.message) {
      errorMessage = error.message;
    }

    if (
      error.details && typeof error.details === "string" &&
      !error.details.startsWith('{"')
    ) {
      errorMessage = error.details;
    }
  } catch (_parseError) {
    errorMessage = "Error al procesar respuesta de base de datos";
  }

  return http500(
    "Error al obtener proveedores",
    `${errorCode !== "unknown" ? `Code ${errorCode}: ` : ""}${errorMessage}`,
  );
}
```

---

## üîÑ **VERIFICACI√ìN DE DUPLICADOS AVANZADA**

```typescript
// deno-lint-ignore no-explicit-any
async function checkDuplicateDocument(
  supabase: any,
  numero_documento: string,
  excludeId?: number,
): Promise<boolean> {
  let query = supabase
    .from("proveedor")
    .select("id")
    .eq("numero_documento", numero_documento);

  if (excludeId) {
    query = query.neq("id", excludeId);
  }

  const { data } = await query.single();
  return !!data;
}
```

---

## üìñ **GET CON AUTENTICACI√ìN OPCIONAL Y FILTROS AVANZADOS**

```typescript
case "GET": {
  // GET /proveedor - Operaciones de lectura (AUTENTICACI√ìN OPCIONAL)
  return withOptionalAuth(async (_req, user) => {
    if (proveedorId) {
      // GET /proveedor/{id} - Obtener proveedor espec√≠fico
      const { data: proveedor, error } = await supabase
        .from("proveedor")
        .select("*")
        .eq("id", proveedorId)
        .single();

      if (error || !proveedor) {
        return http404("Proveedor no encontrado");
      }

      // Enriquecer respuesta si el usuario est√° autenticado
      if (user) {
        return http200({
          proveedor,
          message: "Proveedor encontrado",
          userInfo: {
            viewedBy: user.email,
            canEdit: user.rol === "admin" || user.rol === "supervisor",
            timestamp: new Date().toISOString(),
          },
        });
      }

      // Respuesta b√°sica para usuarios no autenticados
      return http200({
        proveedor,
        message: "Proveedor encontrado",
      });
    } else {
      // GET /proveedor - Listar todos los proveedores con filtros opcionales
      const searchParams = url.searchParams;
      const search = searchParams.get("search") || "";
      const estado = searchParams.get("estado") || "";
      const tipo_documento = searchParams.get("tipo_documento") || "";

      // Validar par√°metros de paginaci√≥n
      const paginationValidation = validatePaginationParams(
        searchParams.get("page") || "",
        searchParams.get("limit") || "",
      );
      if (!paginationValidation.valid) {
        return http400(paginationValidation.error!);
      }
      const { page, limit } = paginationValidation;

      // TypeScript assertion - ya validamos que existen
      const validPage = page!;
      const validLimit = limit!;

      // Validar par√°metros de filtro
      const filterValidation = validateFilterParams(estado, tipo_documento);
      if (!filterValidation.valid) {
        return http400(filterValidation.error!);
      }

      try {
        // Primera query: Solo obtener el count
        let countQuery = supabase
          .from("proveedor")
          .select("*", { count: "exact", head: true });

        // Aplicar filtros al count
        countQuery = applyFilters(countQuery, search, estado, tipo_documento);

        const { count, error: countError } = await countQuery;

        if (countError) {
          return http500("Error al consultar total de registros", countError.message);
        }

        const total = count || 0;
        const totalPages = Math.ceil(total / validLimit);

        // Verificar si la p√°gina solicitada existe
        if (validPage > totalPages && total > 0) {
          return http400(
            `La p√°gina ${validPage} no existe. Solo hay ${totalPages} p√°gina(s) disponible(s) con ${total} registro(s) total(es).`,
          );
        }

        // Segunda query: Obtener los datos con paginaci√≥n
        let dataQuery = supabase.from("proveedor").select("*");

        // Aplicar los mismos filtros
        dataQuery = applyFilters(dataQuery, search, estado, tipo_documento);

        const offset = (validPage - 1) * validLimit;
        dataQuery = dataQuery.range(offset, offset + validLimit - 1);

        const { data: proveedores, error } = await dataQuery;

        if (error) {
          return handleDatabaseError(error);
        }

        // Enriquecer respuesta seg√∫n estado de autenticaci√≥n
        const responseData = {
          data: proveedores || [],
          pagination: {
            page: validPage,
            limit: validLimit,
            total,
            totalPages,
            hasNextPage: validPage < totalPages,
            hasPrevPage: validPage > 1,
          },
          filters: { search, estado, tipo_documento },
          message: total === 0
            ? "No se encontraron proveedores con los filtros aplicados"
            : `Se encontraron ${total} proveedor(es). Mostrando p√°gina ${validPage} de ${totalPages}.`,
        };

        // Si hay usuario autenticado, agregar informaci√≥n adicional
        if (user) {
          return http200({
            ...responseData,
            userInfo: {
              viewedBy: user.email,
              canCreate: user.rol === "admin" || user.rol === "supervisor",
              canEdit: user.rol === "admin" || user.rol === "supervisor",
              viewTimestamp: new Date().toISOString(),
            },
          });
        }

        return http200(responseData);
      } catch (generalError) {
        return http500(
          "Error general",
          `${(generalError as Error).message || "Error desconocido"}`,
        );
      }
    }
  })(req);
}
```

---

## ‚úèÔ∏è **POST CON AUDITOR√çA COMPLETA**

```typescript
case "POST": {
  // POST /proveedor - Crear nuevo proveedor (CON AUDITOR√çA OBLIGATORIA)
  return withAudit(async (_req, auditInfo) => {
    const proveedorData: ProveedorData = await req.json();

    const validation = Validator.validateProveedorData(proveedorData);
    if (!validation.valid) {
      return http400("Datos de proveedor inv√°lidos", {
        errors: validation.errors,
      });
    }

    // Verificar si ya existe proveedor con el mismo documento
    const duplicateExists = await checkDuplicateDocument(
      supabase,
      proveedorData.numero_documento,
    );
    if (duplicateExists) {
      return http400("Ya existe un proveedor con este n√∫mero de documento");
    }

    // Insertar con campos de auditor√≠a autom√°ticos
    const { data: newProveedor, error: createError } = await supabase
      .from("proveedor")
      .insert({
        nombre: proveedorData.nombre,
        razon_social: proveedorData.razon_social,
        tipo_documento: proveedorData.tipo_documento,
        numero_documento: proveedorData.numero_documento,
        email: proveedorData.email,
        telefono: proveedorData.telefono,
        direccion: proveedorData.direccion,
        estado: proveedorData.estado || "registrado",
        ...auditInfo.fields, // Campos de auditor√≠a: created_by, updated_by, created_at, updated_at
      })
      .select()
      .single();

    if (createError) {
      return http500("Error al crear proveedor", createError.message);
    }

    // Respuesta enriquecida con informaci√≥n de auditor√≠a
    return http201(
      enrichWithAuditInfo(newProveedor, auditInfo, "created"),
      "Proveedor creado exitosamente",
    );
  })(req);
}
```

---

## üîÑ **PUT CON AUDITOR√çA Y VALIDACIONES AVANZADAS**

```typescript
case "PUT": {
  // PUT /proveedor/{id} - Actualizar proveedor (CON AUDITOR√çA OBLIGATORIA)
  if (!proveedorId || isNaN(Number(proveedorId))) {
    return http400("ID de proveedor requerido");
  }

  return withAudit(async (_req, auditInfo) => {
    const updateData: Partial<ProveedorData> = await req.json();

    const updateValidation = Validator.validateProveedorData(updateData, true);
    if (!updateValidation.valid) {
      return http400("Datos de proveedor inv√°lidos", {
        errors: updateValidation.errors,
      });
    }

    // Verificar que el proveedor existe
    const { data: existingProveedor } = await supabase
      .from("proveedor")
      .select("id")
      .eq("id", proveedorId!)
      .single();

    if (!existingProveedor) {
      return http404("Proveedor no encontrado");
    }

    // Si se actualiza el documento, verificar que no exista otro con el mismo
    if (updateData.numero_documento) {
      const duplicateExists = await checkDuplicateDocument(
        supabase,
        updateData.numero_documento,
        proveedorId!,
      );
      if (duplicateExists) {
        return http400("Ya existe otro proveedor con este n√∫mero de documento");
      }
    }

    // Actualizar con campos de auditor√≠a
    const { data: updatedProveedor, error: updateError } = await supabase
      .from("proveedor")
      .update({
        ...updateData,
        ...auditInfo.fields, // Campos de auditor√≠a: updated_by, updated_at
      })
      .eq("id", proveedorId!)
      .select()
      .single();

    if (updateError) {
      return http500("Error al actualizar proveedor", updateError.message);
    }

    // Respuesta enriquecida con informaci√≥n de auditor√≠a
    return http200(
      enrichWithAuditInfo(updatedProveedor, auditInfo, "updated"),
      "Proveedor actualizado exitosamente",
    );
  })(req);
}
```

---

## üóëÔ∏è **DELETE CON AUDITOR√çA (SOFT DELETE)**

```typescript
case "DELETE": {
  // DELETE /proveedor/{id} - Eliminar proveedor (CON AUDITOR√çA OBLIGATORIA)
  if (!proveedorId) {
    return http400("ID de proveedor requerido");
  }

  return withAudit(async (_req, auditInfo) => {
    // Verificar que el proveedor existe
    const { data: proveedorToDelete } = await supabase
      .from("proveedor")
      .select("id, estado")
      .eq("id", proveedorId!)
      .single();

    if (!proveedorToDelete) {
      return http404("Proveedor no encontrado");
    }

    // Soft delete: cambiar estado a "inactivo" con auditor√≠a
    const { data: deletedProveedor, error: deleteError } = await supabase
      .from("proveedor")
      .update({
        estado: "inactivo",
        ...auditInfo.fields, // Campos de auditor√≠a: updated_by, updated_at
      })
      .eq("id", proveedorId!)
      .select()
      .single();

    if (deleteError) {
      return http500("Error al eliminar proveedor", deleteError.message);
    }

    // Respuesta enriquecida con informaci√≥n de auditor√≠a
    return http200(
      enrichWithAuditInfo(deletedProveedor, auditInfo, "updated"),
      "Proveedor eliminado exitosamente",
    );
  })(req);
}
```

---

## üéØ **CARACTER√çSTICAS DEL C√ìDIGO COMPLEJO**

### **‚úÖ Ventajas:**
- üîê **Seguridad:** Autenticaci√≥n JWT opcional/obligatoria
- üìä **Auditor√≠a:** Tracking completo de cambios (qui√©n, cu√°ndo, qu√©)
- üîç **B√∫squeda:** Filtros avanzados por m√∫ltiples campos
- ‚úÖ **Validaci√≥n:** Validaciones robustas con Validator personalizado
- üõ°Ô∏è **Error Handling:** Manejo detallado de errores de base de datos
- üìÑ **Paginaci√≥n:** Paginaci√≥n avanzada con metadatos completos
- üö´ **Duplicados:** Verificaci√≥n avanzada de duplicados con exclusiones
- üìà **Metadata:** Respuestas enriquecidas con informaci√≥n contextual

### **‚ùå Complejidad:**
- üîó **Dependencias:** M√∫ltiples utilidades y servicios externos
- üß† **Cognitive Load:** L√≥gica compleja dif√≠cil de seguir
- üêõ **Debugging:** M√°s puntos de falla potencial
- ‚è±Ô∏è **Performance:** M√∫ltiples queries y validaciones
- üìù **Mantenimiento:** M√°s c√≥digo que mantener y actualizar

---

## üìå **CU√ÅNDO USAR CADA VERSI√ìN**

### **üöÄ Versi√≥n Simplificada (Actual):**
- ‚úÖ Prototipado r√°pido
- ‚úÖ Desarrollo inicial
- ‚úÖ APIs internas simples
- ‚úÖ Debugging y testing
- ‚úÖ Productividad inmediata

### **üèóÔ∏è Versi√≥n Compleja (Esta referencia):**
- ‚úÖ Aplicaciones de producci√≥n
- ‚úÖ Sistemas con m√∫ltiples usuarios
- ‚úÖ Requerimientos de auditor√≠a
- ‚úÖ APIs p√∫blicas con filtros avanzados
- ‚úÖ Sistemas con roles y permisos complejos

---

## üîÑ **MIGRACI√ìN DE VUELTA**

Para restaurar la funcionalidad compleja:

1. **Restaurar imports:** Reemplazar imports simples por los complejos
2. **Agregar funciones auxiliares:** Copiar todas las funciones de validaci√≥n y filtros
3. **Reemplazar switch cases:** Sustituir cada case por su versi√≥n compleja
4. **Configurar dependencias:** Asegurar que todas las utilidades est√©n disponibles
5. **Testing:** Probar todas las funcionalidades avanzadas

**Este archivo sirve como referencia completa para cuando necesites restaurar la funcionalidad avanzada.**
